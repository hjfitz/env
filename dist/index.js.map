{"version":3,"sources":["index.js","../src/index.ts"],"names":["Object","defineProperty","exports","value","fs_1","require","re","RegExp","lines","vars","readFileSync","toString","split","ex","forEach","line","isComment","charAt","substring","hasCorrectForm","test","exec","length","unused","key","trimmed","trim","process","env"],"mappings":"AAAA;;AACAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;ACDA,IAAAC,OAAAC,QAAA,IAAA,CAAA;AAEA;AACA,IAAMC,KAAa,IAAIC,MAAJ,CAAW,6CAAX,CAAnB;AACA;AACA,IAAIC,QAAkB,EAAtB;AACA,IAAI;AACF,QAAMC,OAAeL,KAAAM,YAAA,CAAK,MAAL,CAArB;AACA;AACAF,YAAQC,KAAKE,QAAL,GAAgBC,KAAhB,CAAsB,IAAtB,CAAR;AACD,CAJD,CAIE,OAAOC,EAAP,EAAW,CAAE;AACf;AACAL,MAAMM,OAAN,CAAc,UAACC,IAAD,EAAa;AACzB;AACA,QAAMC,YAAqBD,KAAKE,MAAL,CAAY,CAAZ,MAAmB,GAAnB,IAA0BF,KAAKG,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,IAA9E;AACA;AACA,QAAMC,iBAA0Bb,GAAGc,IAAH,CAAQL,IAAR,CAAhC;AACA;AACA,QAAII,kBAAkB,CAACH,SAAvB,EAAkC;AAChC;AACA,YAAMJ,QAAyBN,GAAGe,IAAH,CAAQN,IAAR,CAA/B;AACA,YAAIH,SAASA,MAAMU,MAAN,IAAgB,CAA7B,EAAgC;AACvB,gBAAAC,SAAAX,MAAA,CAAA,CAAA;AAAA,gBAAQY,MAAAZ,MAAA,CAAA,CAAR;AAAA,gBAAaT,QAAAS,MAAA,CAAA,CAAb;AACP;AACA,gBAAMa,UAAkBtB,MAAMuB,IAAN,EAAxB;AACA;AACA,gBAAID,YAAY,EAAhB,EAAoB;AACpBE,oBAAQC,GAAR,CAAYJ,GAAZ,IAAmBC,OAAnB;AACD;AACF;AACF,CAlBD","file":"index.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs_1 = require(\"fs\");\n// load DIRTY regex\nvar re = new RegExp(/^\\s*([\\w\\-\\.]+)\\s*=\\s*([\\w\\-\\.\\s\\:\\/\\?\\=]*)/);\n// read .env\nvar lines = [];\ntry {\n    var vars = fs_1.readFileSync('.env');\n    // split in to lines of key=value\n    lines = vars.toString().split('\\n');\n}\ncatch (ex) { }\n// go through each line and add them to .env\nlines.forEach(function (line) {\n    // allow for # or // to denote a comment\n    var isComment = line.charAt(0) === '#' || line.substring(0, 2) === '//';\n    // check if the line is of the form foo=bar\n    var hasCorrectForm = re.test(line);\n    // if it's of the form var=val or not a comment, parse\n    if (hasCorrectForm || !isComment) {\n        // extract the goods from each\n        var split = re.exec(line);\n        if (split && split.length >= 3) {\n            var unused = split[0], key = split[1], value = split[2];\n            // set process.env.key to the value - removing any whitespace\n            var trimmed = value.trim();\n            // ensure there are no empty keys set\n            if (trimmed === '')\n                return;\n            process.env[key] = trimmed;\n        }\n    }\n});\n","import { readFileSync as read }from 'fs';\n\n// load DIRTY regex\nconst re: RegExp = new RegExp(/^\\s*([\\w\\-\\.]+)\\s*=\\s*([\\w\\-\\.\\s\\:\\/\\?\\=]*)/);\n// read .env\nlet lines: string[] = [];\ntry {\n  const vars: Buffer = read('.env');\n  // split in to lines of key=value\n  lines = vars.toString().split('\\n');\n} catch (ex) {}\n// go through each line and add them to .env\nlines.forEach((line: string) => {\n  // allow for # or // to denote a comment\n  const isComment: boolean = line.charAt(0) === '#' || line.substring(0, 2) === '//';\n  // check if the line is of the form foo=bar\n  const hasCorrectForm: boolean = re.test(line);\n  // if it's of the form var=val or not a comment, parse\n  if (hasCorrectForm || !isComment) {\n    // extract the goods from each\n    const split: RegExpExecArray = re.exec(line);\n    if (split && split.length >= 3) {\n      const [unused, key, value] = split;\n      // set process.env.key to the value - removing any whitespace\n      const trimmed: string = value.trim();\n      // ensure there are no empty keys set\n      if (trimmed === '') return;\n      process.env[key] = trimmed;\n    }\n  }\n});\n"]}