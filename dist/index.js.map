{"version":3,"sources":["index.js","../lib/index.ts"],"names":["Object","defineProperty","exports","value","fs_1","require","debug","re","RegExp","lines","vars","readFileSync","toString","trim","split","ex","forEach","line","isComment","charAt","length","key","slice","process","env","join"],"mappings":"AAAA;;AACAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;ACDA,IAAAC,OAAAC,QAAA,IAAA,CAAA;AACA,IAAMC,QAAQD,QAAQ,OAAR,EAAiB,eAAjB,CAAd;AAEA;AACA,IAAME,KAAa,IAAIC,MAAJ,CAAW,6CAAX,CAAnB;AAEA,IAAIC,QAAkB,EAAtB;AAEA;AACA,IAAI;AACF,QAAMC,OAAeN,KAAAO,YAAA,CAAa,MAAb,CAArB;AACAF,YAAQC,KAAKE,QAAL,GAAgBC,IAAhB,GAAuBC,KAAvB,CAA6B,IAA7B,CAAR;AACD,CAHD,CAGE,OAAOC,EAAP,EAAW,CAAE;AAEf;AACAN,MAAMO,OAAN,CAAc,UAACC,IAAD,EAAa;AACzBX,UAAMW,IAAN;AACA;AACA,QAAMC,YAAqBD,KAAKE,MAAL,CAAY,CAAZ,MAAmB,GAAnB,IAA0BF,KAAKE,MAAL,CAAY,CAAZ,MAAmB,GAAxE;AACA;AACA,QAAI,CAACD,SAAL,EAAgB;AACd;AACA,YAAMJ,QAAkBG,KAAKJ,IAAL,GAAYC,KAAZ,CAAkB,GAAlB,CAAxB;AACA,YAAIA,SAASA,MAAMM,MAAN,IAAgB,CAA7B,EAAgC;AACvB,gBAAAC,MAAAP,MAAA,CAAA,CAAA;AAAA,gBAAKX,QAAAW,MAAAQ,KAAA,CAAA,CAAA,CAAL;AACP;AACA;AACA,gBAAI,CAACD,GAAD,IAAQ,CAAClB,MAAM,CAAN,CAAb,EAAuB;AACvBG,kBAAM,YAAUe,GAAV,GAAa,iBAAnB;AACAE,oBAAQC,GAAR,CAAYH,GAAZ,IAAmBlB,MAAMsB,IAAN,CAAW,GAAX,EAAgBZ,IAAhB,EAAnB;AACD;AACF;AACF,CAjBD","file":"index.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fs_1 = require(\"fs\");\nvar debug = require('debug')('local-env-var');\n// load DIRTY regex\nvar re = new RegExp(/^\\s*([\\w\\-\\.]+)\\s*=\\s*([\\w\\-\\.\\s\\:\\/\\?\\=]*)/);\nvar lines = [];\n// attempt to read file. if it doesn't exist, fail silently\ntry {\n    var vars = fs_1.readFileSync('.env');\n    lines = vars.toString().trim().split('\\n');\n}\ncatch (ex) { }\n// begin parsing each entry\nlines.forEach(function (line) {\n    debug(line);\n    // allow for # or // to denote a comment\n    var isComment = line.charAt(0) === '#' || line.charAt(0) === ';';\n    // if it's of the form var=val or not a comment, parse\n    if (!isComment) {\n        // extract the goods from each\n        var split = line.trim().split('=');\n        if (split && split.length >= 2) {\n            var key = split[0], value = split.slice(1);\n            // set process.env.key to the value - removing any whitespace\n            // ensure there are no empty keys set\n            if (!key || !value[0])\n                return;\n            debug(\"Adding \" + key + \" to process.env\");\n            process.env[key] = value.join('=').trim();\n        }\n    }\n});\n","import { readFileSync } from 'fs';\nconst debug = require('debug')('local-env-var');\n\n// load DIRTY regex\nconst re: RegExp = new RegExp(/^\\s*([\\w\\-\\.]+)\\s*=\\s*([\\w\\-\\.\\s\\:\\/\\?\\=]*)/);\n\nlet lines: string[] = [];\n\n// attempt to read file. if it doesn't exist, fail silently\ntry {\n  const vars: Buffer = readFileSync('.env');\n  lines = vars.toString().trim().split('\\n');\n} catch (ex) {}\n\n// begin parsing each entry\nlines.forEach((line: string) => {\n  debug(line);\n  // allow for # or // to denote a comment\n  const isComment: boolean = line.charAt(0) === '#' || line.charAt(0) === ';';\n  // if it's of the form var=val or not a comment, parse\n  if (!isComment) {\n    // extract the goods from each\n    const split: string[] = line.trim().split('=');\n    if (split && split.length >= 2) {\n      const [key, ...value] = split;\n      // set process.env.key to the value - removing any whitespace\n      // ensure there are no empty keys set\n      if (!key || !value[0]) return;\n      debug(`Adding ${key} to process.env`);\n      process.env[key] = value.join('=').trim();\n    }\n  }\n});\n"]}